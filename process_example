################################################################################
# single process, no blocking:
################################################################################

    loop ( forever ) {
	if ( task.time_scheduled > current_time ) {
	    # run some time in the future
	    sleep_time = task.time_scheduled - current_time
	    sleep( sleep_time )
	} else {
	    # run immediately, we're behind schedule
	}

	run_task()
	reschedule_task( task.cron )
    }


################################################################################
# blocking on single task, only one child process
################################################################################

    pid_child = 0
    loop ( forever ) {
	if ( pid_child != 0 ) {
	    # here we are the parent of a working child process
	    # wait for the child process to finish before we continue
	    waitpid( pid_child, 0 )
	    pid_child = 0
	    reschedule_task( task.cron )
	} else if ( task.time_scheduled > current_time ) {
	    # we have no child processes
	    # run some time in the future
	    sleep_time = task.time_scheduled - current_time
	    sleep( sleep_time )
	} else {
	    # run immediately, we're behind schedule
	}

	pid_child = fork()

	if ( pid_child == 0 ) {
	    # here we're the child
	    run_task();
	    exit( 0 );
	}
    }


################################################################################
# not blocking on single task, only one child process, child time limit
################################################################################
https://sites.google.com/a/taelon.net/ciar/things/python/fork

    set up signal handlers

    pid_child = 0;

    loop ( forever ) {
	if ( pid_child != 0 ) {
	    # here we are the parent of a working child process
	    # wait ttl or the child process to finish before we continue
	    waitpid( pid_child, task.ttl )

	    if ( caught SIGCHLD ) {
		# child exited before ttl elapsed
		clean up child
	    } else {
		# if we are here we have a child that has run too long
		kill child PID
	    }

	    pid_child = 0;
	    reschedule_task( task.cron )
	    continue;

	} else if ( task.time_scheduled > current_time ) {
	    # run some time in the future
	    sleep_time = task.time_scheduled - current_time
	    sleep( sleep_time )
	} else {
	    # run immediately, we're behind schedule
	}

	pid_child = fork()

	if ( pid_child == 0 ) {
	    # here we're the child
	    run_task();
	    exit( 0 );
	}
    }


################################################################################
# not blocking on single task, only one child process, child time limit
# EXAMPLE
################################################################################
https://sites.google.com/a/taelon.net/ciar/things/python/fork

    set up signal handlers

    pid_child = 0;

    loop ( forever ) {
	if ( pid_child != 0 ) {
	    # here we are the parent of a working child process
	    # wait ttl or the child process to finish before we continue
	    waitpid( pid_child, 5 )

	    if ( caught SIGCHLD ) {
		# child exited before ttl elapsed
		clean up child
		print out child exit status
	    } else {
		# if we are here we have a child that has run too long
		kill child PID
		print out that we killed the child
	    }

	    pid_child = 0;
	    continue;
	}

	pid_child = fork()

	if ( pid_child == 0 ) {
	    # here we're the child
	    sleep( random 1-10 seconds)
	    exit( 0 );
	}
    }


################################################################################
# not blocking on single task, single child process with time limit, RabbitMQ
################################################################################

    set up RabbitMQ

    set up signal handlers

    pid_child = 0;

    loop ( forever ) {
	if ( pid_child != 0 ) {
	    # here we are the parent of a working child process
	    # wait ttl or the child process to finish before we continue
	    waitpid( pid_child, task.ttl )
	} else if ( task.time_scheduled > current_time ) {
	    # run some time in the future
	    sleep_time = task.time_scheduled - current_time
	    sleep( sleep_time )
	} else {
	    # run immediately, we're behind schedule
	}

	if ( RabbitMQ is ready to send us a message ) {
	    clear handlers
	    receive Rabbit message
	    do actions
	    continue;
	}

	if ( pid_child != 0 ) {
	    if ( caught SIGCHLD ) {
		# child exited before ttl elapsed
		clean up child
	    } else 
		# if we are here we have a child that has run too long
		kill child PID
	    }

	    pid_child = 0;
	    reschedule_task( task.cron )
	    continue;
	}

	pid_child = fork()

	if ( pid_child == 0 ) {
	    # here we're the child
	    run_task();
	    exit( 0 );
	}
    }



################################################################################
# not blocking on single task, single child process with time limit, RabbitMQ
################################################################################

    set up RabbitMQ

    set up signal handlers

    pid_child = 0;

    SSID_scan()

    loop ( forever ) {
	if ( pid_child != 0 ) {
	    # here we are the parent of a working child process
	    # wait ttl or the child process to finish before we continue
	    waitpid( pid_child, task.ttl )
	} else if ( task.time_scheduled > current_time ) {
	    # run some time in the future
	    sleep_time = task.time_scheduled - current_time
	    sleep( sleep_time )
	} else {
	    # run immediately, we're behind schedule
	}

	if ( RabbitMQ is ready to send us a message ) {
	    clear handlers
	    receive Rabbit message
	    do actions
	    continue;
	}

	if ( pid_child != 0 ) {
	    if ( caught SIGCHLD ) {
		# child exited before ttl elapsed
		clean up child
	    } else 
		# if we are here we have a child that has run too long
		kill child PID
	    }

	    pid_child = 0;
	    reschedule_task( task.cron )
	    continue;
	}

	if ( task.type == SSID_SCAN ) {
	    # build table of SSIDs we care about and component BSSIDs
	    SSID_scan()
	} else {
	    new_BSSID_list( existimg_list, SSID_name, min_signal_strength )
	
	    TTL = number of prequalified BSSIDs * TTL seconds

	    if ( TTL == 0 ) {
		# no prequalified BSSIDs
		continue;
	    }

	    pid_child = fork( task with prequalified BSSIDs )

	    if ( pid_child == 0 ) {
		# here we're the child
		run_task( task );
		exit( 0 );
	    }
	}
    }

